# xv6-riscv README

## Overview

**xv6 is a complete, working command-line operating system** for RISC-V computers. It is a modern re-implementation of Dennis Ritchie and Ken Thompson's **Unix Version 6 (v6)**. It follows the original structure and design philosophy of v6 but is re-written in **ANSI C** for the **RISC-V multiprocessor architecture**. xv6 is widely used as an educational operating system in MIT's 6.1810 Operating Systems course.

### Complete Operating System Features

This project provides a **fully functional command-line operating system** with the following core components:

#### ðŸ–¥ï¸ **Command-Line Shell**
- Interactive shell (`sh.c`) with command parsing
- Supports command execution, redirection (`>`, `<`), and pipelines (`|`)
- Built-in commands: `cd`, `ls`, `cat`, `echo`, `grep`, `mkdir`, `rm`, `kill`, `sleep`, etc.

#### ðŸ“ **File System**
- Complete inode-based file system with journaling
- Supports regular files, directories, and device files
- File operations: create, read, write, delete, link, unlink
- Directory navigation and management

#### ðŸ”„ **Process Management**
- Multi-process support with `fork()`, `exec()`, `wait()`, `exit()`
- Round-robin scheduling across multiple CPU cores
- Process synchronization and inter-process communication

#### ðŸ’¾ **Memory Management**
- RISC-V Sv39 paging with virtual memory
- Separate kernel and user address spaces
- Page allocation and management

#### ðŸ”§ **System Calls**
- Complete system call interface (20+ system calls)
- User-kernel mode switching via RISC-V `ecall` instruction
- System calls for file operations, process management, and synchronization

#### ðŸ†• **New Feature: Semaphore Synchronization**
This customized version **extends** the base xv6 with **semaphore synchronization primitives** and includes demonstration programs to verify inter-process communication and synchronization.

---

## New Features in This Project

### ðŸ§© Semaphore System Calls

Newly implemented system calls for process synchronization:

| System Call           | Description                                 |
| --------------------- | ------------------------------------------- |
| `sem_init(int value)` | Initialize a semaphore with a given count   |
| `sem_wait(int id)`    | Wait (decrement), block if value <= 0       |
| `sem_post(int id)`    | Signal (increment), wake up waiting process |
| `sem_free(int id)`    | Free a semaphore and release resources      |

* Implemented in: `kernel/semaphore.c`
* Kernel linkage through: `sysproc.c`, `syscall.c`, `syscall.h`
* User-level interface: `user/semtest.c`, `user/prodcons.c`

---

## Demonstration Programs

### 1. **semtest.c**

A simple parent-child synchronization test:

* The child waits using `sem_wait()`.
* The parent releases it using `sem_post()`.

Expected Output:

```
Parent: waiting on semaphore...
Child: semaphore acquired!
```

### 2. **prodcons.c**

Implements the **Producer-Consumer problem** using semaphores:

* Ensures mutual exclusion and synchronization.
* Demonstrates inter-process communication.

Expected Output:

```
Producer: produced item 1
Consumer: consumed item 1
Producer finished!
Consumer finished!
All items processed!
```

---

## xv6 System Architecture Summary

For detailed system design and subsystem descriptions, refer to the accompanying documentation:
ðŸ“„ `System_Architecture.md`

Covers:

* Boot and initialization sequence
* Process scheduling (Round Robin)
* Memory management (Sv39 paging)
* File system structure (inode + journaling)
* System call mechanism and semaphore synchronization

---

## Build and Run Instructions

### 1. Install Dependencies (macOS / Linux)

```bash
brew install qemu riscv-tools
```

### 2. Build xv6 for RISC-V

```bash
make TOOLPREFIX=riscv64-unknown-elf-
```

### 3. Run xv6 in QEMU

```bash
make qemu TOOLPREFIX=riscv64-unknown-elf-
```

### 4. Inside xv6 Shell

Once xv6 boots, you'll see the command prompt `$`. This is a **fully functional command-line operating system**. You can use standard Unix commands:

**Basic Commands:**
```bash
$ ls              # List files
$ cat README      # Display file contents
$ echo hello      # Print text
$ mkdir test      # Create directory
$ rm file         # Delete file
$ grep pattern file  # Search in files
```

**Run Multiple Programs:**
```bash
$ sleep 10 &      # Run in background
$ forktest        # Test fork functionality
```

**Use Shell Features:**
```bash
$ echo hello | grep hello    # Pipeline
$ ls > output.txt            # Redirection
$ cat file1 file2            # Multiple arguments
```

**Test Semaphore Features (New):**
```bash
$ semtest         # Test semaphore synchronization
$ prodcons        # Test producer-consumer problem
```

**Exit the Shell:**
Press `Ctrl+A` then `X` to exit QEMU (xv6 shell doesn't have built-in `exit` command)

---

## Acknowledgments

xv6 is based on the work of:

* Dennis Ritchie and Ken Thompson (original Unix v6)
* MIT CSAIL PDOS group: Russ Cox, Frans Kaashoek, and Robert Morris

See the original xv6 distribution and documentation at:
ðŸ‘‰ [https://pdos.csail.mit.edu/6.1810/](https://pdos.csail.mit.edu/6.1810/)

---

## AI Tool Usage and Prompts

This project was developed with assistance from AI tools (ChatGPT). Below are the actual prompts used during development, organized by category.

### Environment Setup and Installation

1. **macOS RISC-V Toolchain Installation**
   - "I'm using macOS, please guide me on how to install the riscv64-unknown-elf toolchain."

2. **Xcode Command Line Tools**
   - "brew install gcc failed, it requires Xcode Command Line Tools. What should I do?"

### Build System and Makefile Issues

3. **Makefile Syntax Errors**
   - "Why do I get 'commands commence before first target' error when running make?"
   - "Why does make qemu always fail? What are the possible causes?"
   - "Why does make report 'missing separator' error?"

4. **File Path and Location**
   - "Why does exec fail when running sleep? Where should sleep.c be placed?"
   - "Why can't semtest execute? I've already added it to Makefile."

### System Usage

5. **QEMU and Shell Navigation**
   - "How do I exit xv6 shell? How do I return to macOS terminal?"

### Code Implementation and Debugging

6. **System Call Implementation**
   - "Which files need to be modified to add a system call? Please tell me step by step."
   - "Why is sys_sleep defined multiple times? How should code be split between syscall.c and sysproc.c?"
   - "Why do I get 'multiple definition of fetchstr / fetchaddr' errors?"
   - "Why does syscalls[] go out of bounds? How should the numbering be arranged?"
   - "Should sem_init / sem_wait / sem_post / sem_free go in syscall.c or sysproc.c?"

7. **Semaphore Implementation**
   - "Why does semtest show 'unknown sys call'?"
   - "Why does semaphore_wait need a while loop? How do sleep and wakeup work together correctly?"
   - "How to implement a correctly blocking semaphore_wait in xv6?"

8. **Program Output and Behavior**
   - "Why is semtest output garbled? Is there a problem with printf or the user program?"
   - "Why is prodcons output order not fixed? Is this normal?"

9. **Producer-Consumer Implementation**
   - "How should prodcons.c be written? How to use two semaphores to implement producer-consumer?"






## Notes on AI Assistance

- AI tools were used primarily for:
  - Troubleshooting build and compilation errors
  - Understanding xv6 system call mechanism
  - Implementing semaphore synchronization primitives
  - Debugging Makefile syntax issues
  - Writing documentation

- All code was tested and verified independently after AI assistance
- Understanding of the code was achieved through studying xv6 source code and documentation

---

## Author

**Kaidi Lyu**
University of South Carolina
*Operating Systems Project â€” xv6 Semaphore Extension*
